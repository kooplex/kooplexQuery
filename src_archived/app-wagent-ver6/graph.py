# from typing import TypedDict, Literal
from typing import Annotated, TypedDict, Literal

from langgraph.prebuilt import ToolNode
from langchain_core.tools import tool, StructuredTool
from langgraph.graph import START, StateGraph
from langgraph.graph.message import AnyMessage, add_messages
from langchain_community.utilities import DuckDuckGoSearchAPIWrapper
from langchain_core.messages import AIMessage, ToolMessage, HumanMessage
from langchain_openai import ChatOpenAI
# from langchain_community.chat_models import ChatOpenAI
from pydantic import BaseModel, Field

from tool_library import translate_to_sql_tool, explain_database_tool

import logging
logger = logging.getLogger(__name__)

# Define a search tool using DuckDuckGo API wrapper
search_DDG = StructuredTool.from_function(
        name="Search",
        func=DuckDuckGoSearchAPIWrapper().run,  # Executes DuckDuckGo search using the provided query
        description=f"""
        useful for when you need to answer questions about current events. You should ask targeted questions
        """,
    )

text2sql = StructuredTool.from_function(
        name="Sewage_Text_to_SQL",
        func=translate_to_sql_tool, 
        infer_schema=False,
        description=f"""
        Useful when you need to retrieve data from the Sewage database by translating the user question to SQL query
        """,
    )

class Question(BaseModel):
    """Explain the user question about the database"""
    question: str = Field(str , description="The user's question or request for information")
    # answer: str = Field(str , description="The answer generated by the tool")

explain = StructuredTool.from_function(
        name="Sewage_Database_Explain",
        args_schema=Question,
        func=explain_database_tool, 
        infer_schema=False,
        description=f"""
        Useful when you need to answer question or retrieve information about the Sewage database using the given database schema and table, column descriptions
        """,
    )

@tool
def get_weather(location: str):
    """Call to get the current weather."""
    # A simplified weather response based on location
    if location.lower() in ["sf", "san francisco"]:
        return "It's 60 degrees and foggy."
    else:
        return "It's 90 degrees and sunny."

@tool
def get_coolest_cities():
    """Get a list of coolest cities."""
    # Hardcoded response with a list of cool cities
    return "nyc, sf"

# List of tools that will be accessible to the graph via the ToolNode
# tools = [text2sql, search_DDG]
tools = [text2sql, explain, search_DDG]
tool_node = ToolNode(tools)

# This is the default state same as "MessageState" TypedDict but allows us accessibility to custom keys
class GraphsState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    # Custom keys for additional data can be added here such as - conversation_id: str

graph = StateGraph(GraphsState)

# Function to decide whether to continue tool usage or end the process
def should_continue(state: GraphsState) -> Literal["tools", "__end__"]:
    messages = state["messages"]
    last_message = messages[-1]
    logger.info(f"LLM Raw Response: {response}")
    if isinstance(response, str) or isinstance(response.content, str):
        import json
        try:
            tool_call = json.loads(response.content)
            logger.info(f"Parsed tool_call: {tool_call}")
        except Exception as e:
            logger.error(f"Failed to parse tool_call: {e}")

    if last_message.tool_calls:  # Check if the last message has any tool calls
        return "tools"  # Continue to tool execution
    return "__end__"  # End the conversation if no tool is needed

ollama_host = "http://wfct0p-ollamaapi:11434"
agent_model = "llama3.2"

# Core invocation of the model
def _call_model(state: GraphsState):
    messages = state["messages"]
    llm = ChatOpenAI(
        temperature=0.7,
        openai_api_key="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",
        streaming=True,
    ).bind_tools(tools)
    logger.info(f"_Call model")
    print(messages)
    # llm = ChatOpenAI(temperature=0, streaming=True,
    #                  model_name=agent_model, openai_api_key="dsadaa",
    #                  openai_api_base=ollama_host+"/v1").bind_tools(tools)
    response = llm.invoke(messages)
    # response = llm.invoke(
    # [HumanMessage(content=m["content"]) for m in messages],  # or however your messages are stored
    # config=RunnableConfig()
# )
    logger.info(f"LLM Response: {response}")
    logger.info(f"Tool Calls in model response: {getattr(response, 'tool_calls', None)}")
    return {"messages": [response]}  # add the response to the messages using LangGraph reducer paradigm

# Define the structure (nodes and directional edges between nodes) of the graph
graph.add_edge(START, "modelNode")
graph.add_node("tools", tool_node)
graph.add_node("modelNode", _call_model)

# Add conditional logic to determine the next step based on the state (to continue or to end)
graph.add_conditional_edges(
    "modelNode",
    should_continue,  # This function will decide the flow of execution
)
graph.add_edge("tools", "modelNode")

# Compile the state graph into a runnable object
graph_runnable = graph.compile()

# Function to invoke the compiled graph externally
def invoke_our_graph(st_messages, callables):
    # Ensure the callables parameter is a list as you can have multiple callbacks
    if not isinstance(callables, list):
        raise TypeError("callables must be a list")
    logger.info(f"_Invoke graph")
    # Invoke the graph with the current messages and callback configuration
    return graph_runnable.invoke({"messages": st_messages}, config={"callbacks": callables})
